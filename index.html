<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <title>Endangered Species!</title>
    <link rel="shortcut icon" type="image/png" href="http://localhost:8000/assets/favicon.png">
    <style>

        .states {
            fill: #ccc;
            stroke: #fff;
        }


        circle {
            fill: steelblue;
            fill-opacity: .8;
            stroke: #fff;
        }


        .tooltip {
            position: absolute;
            text-align: center;
            width: 60px;
            height: auto;
            padding: 2px;
            font: 12px sans-serif;
            background: lightsteelblue;
            border: 0px;
            border-radius: 8px;
            pointer-events: none;
        }

        /*
            Pie Charts
        */
        .arc text {
            font: 10px sans-serif;
            text-anchor: middle;
        }

        .arc path {
            stroke: #fff;
        }


        .background {
            fill: none;
            pointer-events: all;
        }


        #states .active {
            fill: orange;
        }
    </style>

</head>
<body>
<div id="content">
    <div id="map" style="border:1px dotted blue; height: 500px; width: 850px; overflow: hidden; float: left; " ></div>

    <div id="info" style="border:1px dotted blue; width: 250px; height: 500px; float:left; background-color: white; margin-left: 10px;" >
        <img id="logo" src="img/logo.png">
        <p id="textCountryName">Endangered Species Information Visualisation</p>
        <div id="chart"></div>
    </div>
</div>
<!--div id="container1" style="border:1px dotted blue; width: 700px; height: 475px; position: relative;"></div-->
<!--script src="/components/d3/d3.min.js"></script-->
<script src="https://d3js.org/d3-array.v1.min.js"></script>
<script src="https://d3js.org/d3-geo.v1.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<script src="https://d3js.org/d3.v4.min.js"></script>


<script>

    var width = 880,
        height = 500,
        widthPie = 250,
        heightPie = 250;

    var projection = d3.geoNaturalEarth()
        .scale(175)
        .translate([width / 2, height / 2]);

    var arcdataTrade = [];
    var arcdataTradeSelected = [];

    var countryCodeCenters = [];
    var countryCodes = [];

    var forestData = [];


    /*
    * lc = least concern
    * nt = near threatened
    * LR/cd = Lower Risk (conservation dependent)
    * LR/nt = Lower Risk (near threatened)
    * LR/lc = Lower Risk (least concern)
    * vu = vulnerable
    * en = endangered
    * cr = critically endangered
    * ew = extinct in the wild
    * ex = extinct
    * dd = data deficient
    * ne = not evaluated
    *
    * */

    var oneCountrySelected = false;
    var selectedCountry = "None";
    var formerSelection;

    var path = d3.geoPath()
        .projection(projection);

    var zoom = d3.zoom()
    //.translateTo([defaultTranslateX, defaultTranslateY])
        //.scaleExtent([1, 8])
        .on("zoom", zoomed);

    var svg = d3.select("#map").append("svg")
        .attr("width", width)
        .attr('transform', 'translate('+-50+')')
        .attr("height", height);

    var svgPie = d3.select("#info").append("svg")
        .attr("width", widthPie)
        .attr("height", heightPie);

    svg.append("rect")
        .attr("class", "background")
        .attr("width", width)
        .attr("height", height)
        .on("click", reset)
        .on("mouseover", function (d){
            tooltip.transition()
                .duration(200)
                .style("opacity", 0);

        });

    var states = svg.append("g")
        .attr("id", "states") ;

    var g = svg.append("g"); // states, trades
    var g1 = svgPie.append("g"); // Pie Chart


    svg
        .call(zoom); // delete this line to disable free zooming

    var arcsTrade = g.append("g")
        .attr("id","arcsTrade");

    var tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);



    // ----------------- Countries -------------------------------

    /*from http://colorbrewer2.org/#type=diverging&scheme=RdYlGn&n=9
    * #d73027
     #f46d43
     #fdae61
     #fee08b
     #ffffbf
     #d9ef8b
     #a6d96a
     #66bd63
     #1a9850
    * */
    var colorForest = d3.scaleOrdinal(["#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850" ]);
    //var colorForest = d3.scaleOrdinal(["#1a9850", "#66bd63", "#a6d96a", "#d9ef8b", "#ffffbf", "#fee08b", "#fdae61", "#f46d43", "#d73027" ]);

    i=0;
    d3.json("data/countries.geo.json", function(collection) {
        g.selectAll("path")
            .data(collection.features)
            .enter().append("path")
            .attr("d", path)
            .attr("class", "states")
            .style("fill", function(d) {
                console.log(forestData.length);
                for(i=0; i<forestData.length; i++) {
                    console.log(forestData[i].country + " .. " + d.properties.name);
                    if (d.properties.name === forestData[i].country) {
                        console.log(forestData[i].country + " .. " + forestData[i].deforestation);
                        var deforestation = forestData[i].deforestation;
                        break;
                    }
                }
                return colorForest(deforestation);
                })

            .on("click", clicked)
            .on("mouseover", function (d){
                tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
                tooltip.html(d.properties.name + "<br/>" + "lulu")
                    .style("left", (d3.event.pageX) + "px")
                    .style("top", (d3.event.pageY - 28) + "px");
            });
        collection.features.forEach(function(coords) {
            var countrycode = getFromArrayByCountryName(countryCodes, coords.properties.name);
            if (countrycode == null) countrycode = ({countryname: coords.properties.name, countrycode2: "not available"});;
            countryCodeCenters.push({country: coords.properties.name, codetwo: countrycode.countrycode2, codethree: coords.id, center: getCenter(coords, coords.geometry.type).coordinates});
        });


    });

    // ------------  Forest Data  -----------------------

    d3.csv("/data/ForestPercent.csv", function (countries){
        countries.forEach(function (country) {
            var cName = country.Country,
                startArea= country.y2015,
                endArea = country["2000"];



                var deforestation = startArea - endArea;
            console.log("DEFORESTATION: "+  deforestation);

                if (startArea != null && endArea != null) { //if the country codes are available!
                    forestData.push({
                        country: cName,
                        deforestation: deforestation
                    });

                }
                else {
                    console.log("no year data for " + cName);
                }
            });
            console.log(forestData); //shows if loading was successfull...

    });



    // ------------------- RED LIST Api Request ----------------------------



        var token = "?token=9bb4facb6d23f48efbf424bb05c0c1ef1cf6f468393bc745d42179ac4aca5fee";
        var countryRequest = "AZ";
        var pageNr = 0;
        var requestSpeciesCountry = "country/getspecies/";
        var requestTotalSpeciesNumber = "speciescount";

        var url = "http://apiv3.iucnredlist.org/api/v3/";

        // FALSCHE DATEN !!! jedes einzelne LAND -> species doppelt für regionen!!!







    // ---------------------- Pie Charts ----------------------------------





        var radiusPie = 100;


    var colorPie = d3.scaleOrdinal(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);
    var pie = d3.pie()
        .sort(null)
        .value(function(d) { return d.value; });

    var pathPie = d3.arc()
        .outerRadius(radiusPie - 10)
        .innerRadius(0);

    var label = d3.arc()
        .outerRadius(radiusPie - 40)
        .innerRadius(radiusPie - 40);


    d3.csv("/data/speciesGlobal.csv", function(d) {
        return d;
    }, function(error, data) {
        if (error) throw error;
        console.log(data);

        var arc = g1.selectAll(".arc")
            .data(pie(data))
            .enter().append("g")
            .attr("class", "arc").attr('transform', 'translate(' + radiusPie +
                ',' + radiusPie + ')');

        arc.append("path")
            .attr("d", pathPie)
            .attr("fill", function(d) { return colorPie(d.data.value); });

        arc.append("text")
            .attr("transform", function(d) { return "translate(" + label.centroid(d) + ")"; })
            .attr("dy", "0.35em")
            .text(function(d) { return d.data.status; });
    });


        console.log("show me pie chart?");




    // --------------- Zoom & Pan functionality -----------------------------


    function zoomed() {
        g.style("stroke-width", 1.5 / d3.event.transform.k + "px");
        g.attr("transform", d3.event.transform); // updated for d3 v4

    }

    function reset() {

        svg.transition()
            .duration(750)
            .call( zoom.transform, d3.zoomIdentity );
    }




    // --------------------- Click functionality -----------------------------

    function clicked(d) {

        console.log(d);

        var selection = d3.select(this);

        console.log(selection);

        // Case: No Country is selected yet, the one that gets clicked => gets selected!
        if (oneCountrySelected == false && d.properties.name != selectedCountry){

            selectedCountry = d.properties.name;
            oneCountrySelected = true;
            formerSelection = selection;

            selection.style("fill", "black");
            selection.classed("selected", true);


            //sehr unperformant weil jedesmal über die csv drüber iteriert wird. besser wenn array direkt geschrieben wird ???

            writeCountryTradesToArray(d);
            viewTradesOfCountry();

            changeInfoText(d, true);
        }

        // Case: One Country is already selected, this one gets clicked again => deselect it!
        else if (oneCountrySelected == true && d.properties.name == selectedCountry) {

            selectedCountry = "None";
            oneCountrySelected = false;

            changeInfoText(d, false);
            deselectCountry(selection);
        }

        // Case: One Country is already selected, another one gets clicked => deselect it and select new one!
        else if (oneCountrySelected == true && d.properties.name != selectedCountry) {

            if (formerSelection.classed("selected")) {
                formerSelection.classed("selected", false);
                formerSelection.style("fill", "LightGray");
            }

            selectedCountry = d.properties.name;
            formerSelection = selection;
            oneCountrySelected = true;

            deselectCountry(selection);
            writeCountryTradesToArray(d);
            viewTradesOfCountry();
            changeInfoText(d, true);

            selection.style("fill", "black");
            selection.classed("selected", true);

        }
    }

    function writeCountryTradesToArray(d) {

        var countByCountry = {},
            locationByCountry = {};

        arcdataTrade.forEach(function (trade) {
            var importer = trade.importCountry,
                exporter = trade.exportCountry,
                importLocation = trade.importLocation,
                exportLocation = trade.exportLocation,
                importQuants = trade.importQuant;

            if (exporter == d.properties.name) {

                countByCountry[importer] = (countByCountry[importer] || 0) + 1;
                arcdataTradeSelected.push({
                    exportCountry: exporter, importCountry: importer,
                    exportLocation: exportLocation,
                    importLocation: importLocation,
                    importQuant: importQuants,
                    importPerCountry: countByCountry[importer]
                });
            }
        });
    }

    function viewTradesOfCountry() {

        g.selectAll("arcsTrade")
            .data(arcdataTradeSelected)
            .enter()
            .append("path")
            .attr("class", "arcsTrade")
            .style("stroke", "Red")
            .style("fill", "none")
            .style("stroke-width", function (d) {

                if(d.importPerCountry == null || d.importPerCountry <= 5) return 1;
                else if(d.importPerCountry > 5 || d.importPerCountry <= 10) return 2;
                else if(d.importPerCountry > 10 || d.importPerCountry <= 25) return 3;
                else if(d.importPerCountry > 25 || d.importPerCountry <= 50) return 5;
                else if(d.importPerCountry > 50 ) return 10;
                // A bend of 5 looks nice and subtle, but this will depend on the length of your arcs and the visual look your visualization requires. Higher number equals less bend.
            })
            .attr('d', function (d) {
                return lngLatToArc(d, 'exportLocation', 'importLocation', 0); // A bend of 5 looks nice and subtle, but this will depend on the length of your arcs and the visual look your visualization requires. Higher number equals less bend.
            });
    }

    function deselectCountry(selection) {

        //empty Trade Data Array !
        arcdataTradeSelected = [];


        var test = g.selectAll("path.arcsTrade").data(arcdataTradeSelected, function (d) {
            return d.id;
        });

        //path needs to be on update+enter to delete/remove arcs
        test.enter()
            .append("path")
            .attr('d', function (d) {
                return lngLatToArc(d, 'exportLocation', 'importLocation', 25); // A bend of 5 looks nice and subtle, but this will depend on the length of your arcs and the visual look your visualization requires. Higher number equals less bend.
            });

        test.exit().remove();

        selection.classed("selected", false);
        selection.style("fill", "LightGray");
    }

    function changeInfoText (d, selectedBool) {
        if(selectedBool == true){
        document.getElementById("textCountryName").innerHTML = d.properties.name;}
        else {
        document.getElementById("textCountryName").innerHTML = "Select a country to see the trades";
        }
    }

    // ----------------------------- DATA (still airport)-----------------------------------------


    d3.csv("/data/animalTrade.csv", function(trades) {
        var linksByExporter = {},
            countByCountry = {},
            locationByCountry = {};

        trades.forEach(function (trade) {
            var importer = trade.Importer,
                exporter = trade.Exporter,
                quantityImp = trade['Importer reported quantity'], //empty spaces!!!
                links = linksByExporter[exporter] || (linksByExporter[exporter] = []);


            links.push({exportCountry: exporter, importCountry: importer});
            var exportInfo = getFromArrayByTwoDigits(countryCodeCenters, exporter);
            var importInfo = getFromArrayByTwoDigits(countryCodeCenters, importer);
            if (exportInfo != null && importInfo != null) { //if the country codes are available!
                    arcdataTrade.push({
                        exportCountry: exportInfo.country, importCountry: importInfo.country,
                        exportLocation: exportInfo.center,
                        importLocation: importInfo.center,
                        importQuant: quantityImp
                    });

            }
        });
        console.log(arcdataTrade); //shows if loading was successfull...

    });

    /*rename of Russian Federation -> Russia
    Congo, the Democratic Republic of the -> Democratic Republic of the Congo
     United States -> United States of America
     "Bolivia, Plurinational State of -> Bolivia
     Venezuela, Bolivarian Republic of -> Venezuela
     Syrian Arab Republic -> Syria
     Tanzania, United Republic of -> United Republic of Tanzania
     Côte d'Ivoire -> Ivory Coast
     Iran, Islamic Republic of -> Iran
     Viet Nam -> Vietnam
     Korea, Republic of -> South Korea
     Korea, Democratic People's Republic of -> North Korea
     Taiwan, Province of China -> Taiwan
    */
    d3.csv("/data/cc2digit.csv", function(codes) {
        codes.forEach(function (code) {
            countryCodes.push({countryname: code.Name, countrycode2: code.Code});
        });
    });



        // ----------------------------- Functions -----------------------------------------

    function getCenter(polygon, geometryType) {
        if ('geometry' in polygon) polygon = polygon.geometry

        if (!Array.isArray(polygon)) {
            if (geometryType == "Polygon") {
                polygon = polygon.coordinates[0]
            }
            //find out the centerpoint of the largest coordinate array!
            else if (geometryType == "MultiPolygon") {

                var counter = 0;
                var longestArray = 0;
                var longestArrayLength = 0;
                polygon.coordinates.forEach(function (arrays) {
                    arrays.forEach(function (arraySecond){
                        counter = counter + 1;
                        if(arraySecond.length > longestArrayLength){
                            longestArrayLength = arraySecond.length;
                            longestArray = counter;
                        }
                    });
                });
                polygon = polygon.coordinates[longestArray-1][0]
            }
        }


        var minx = miny = 1000
            ,   maxx = maxy = -1000
        for (var i = 0; i < polygon.length; i++) {
            var point = polygon[i]
            var x = point[0]
            var y = point[1]

            if (x < minx) minx = x
            else if (x > maxx) maxx = x
            if (y < miny) miny = y
            else if (y > maxy) maxy = y
        }

        return {
            type: 'Point',
            coordinates: [
                minx + ((maxx - minx) / 2),
                miny + ((maxy - miny) / 2)
            ]
        }
    }

    function getFromArrayByCountryName(arr, value) {

        var result = [];
        arr.forEach(function(o){if (o.countryname === value) result.push(o);} );
        return result? result[0] : null; // or undefined
    }

    function getFromArrayByTwoDigits(arr, value) {

        var result = [];
        arr.forEach(function(o){if (o.codetwo === value) result.push(o);} );
        return result? result[0] : null; // or undefined

    }





    // ----------------------------- Center of Country -----------------------------------------

    // This function takes an object, the key names where it will find an array of lng/lat pairs, e.g. `[-74, 40]`
    // And a bend parameter for how much bend you want in your arcs, the higher the number, the less bend.
    function lngLatToArc(d, sourceName, targetName, bend){
        // If no bend is supplied, then do the plain square root
        //console.log(d);
        bend = bend || 1;
        // `d[sourceName]` and `d[targetname]` are arrays of `[lng, lat]`
        // Note, people often put these in lat then lng, but mathematically we want x then y which is `lng,lat`

        var sourceLngLat = d[sourceName],
            targetLngLat = d[targetName];

        if (targetLngLat && sourceLngLat) {
            var sourceXY = projection( sourceLngLat ),
                targetXY = projection( targetLngLat );

            // Uncomment this for testing, useful to see if you have any null lng/lat values
            // if (!targetXY) console.log(d, targetLngLat, targetXY)
            var sourceX = sourceXY[0],
                sourceY = sourceXY[1];

            var targetX = targetXY[0],
                targetY = targetXY[1];

            var dx = targetX - sourceX,
                dy = targetY - sourceY,
                dr = Math.sqrt(dx * dx + dy * dy)*bend;

            // To avoid a whirlpool effect, make the bend direction consistent regardless of whether the source is east or west of the target
            var west_of_source = (targetX - sourceX) < 0;
            if (west_of_source) return "M" + targetX + "," + targetY + "A" + dr + "," + dr + " 0 0,1 " + sourceX + "," + sourceY;
            return "M" + sourceX + "," + sourceY + "A" + dr + "," + dr + " 0 0,1 " + targetX + "," + targetY;

        } else {
            return "M0,0,l0,0z";
        }
    }

</script>
</body>