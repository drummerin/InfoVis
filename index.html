<!DOCTYPE html>
<meta charset="utf-8">
<head>
    <style>

        #states path {
            fill: #ccc;
            stroke: #fff;
        }

        arc {
            fill: #d45138;
            stroke: #d45138;
        }

        path.arc {
            fill: #d45138;
            stroke: #d45138;
        }

        circle {
            fill: steelblue;
            fill-opacity: .8;
            stroke: #fff;
        }

        #cells.voronoi path.cell {
            stroke: brown;
        }

        #cells g:hover path.arc {
            display: inherit;
        }
    </style>
</head>
<body>

<div id="mapi" style="border:1px dotted blue; width: 200px; height: 475px; position: absolute; right: 10px;"></div>
<!--div id="container1" style="border:1px dotted blue; width: 700px; height: 475px; position: relative;"></div-->
<script src="/components/d3/d3.min.js"></script>
<script src="https://d3js.org/d3-array.v1.min.js"></script>
<script src="https://d3js.org/d3-geo.v1.min.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>


<script>

    var margin = {top: 20, right: 20, bottom: 30, left: 40},
        width = (window.innerWidth - 250) - margin.left - margin.right,
        height = (window.innerHeight -50)  - margin.top - margin.bottom;

    var defaultZoom = 1;
    var defaultTranslateX = 0;
    var defaultTranslateY = 0;

    var projection = d3.geoNaturalEarth();
        //.scale(200);

    var arcdataTrade = [];
    var arcdataTradeSelected = [];

    var path = d3.geo.path()
        .projection(projection);

    var svg = d3.select("body").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


    var states = svg.append("svg:g")
        .attr("id", "states") ;

    var circles = svg.append("svg:g")
        .attr("id", "circles");

    var cells = svg.append("svg:g")
        .attr("id", "cells");

    // Group for the arcs
    var arcs = svg.append("g")
        .attr("class","arcs");

    var arcsTrade = svg.append("g")
        .attr("class","arcsTrade");


    var g = svg.append("g");


    /*d3.select("input[type=checkbox]").on("change", function() {
        cells.classed("voronoi", this.checked);
    });*/

    var countryCodeCenters = [];
    var countryCodes = [];

    d3.json("data/countries.geo.json", function(collection) {
        states.selectAll("path")
            .attr("id", "states")
            .data(collection.features)
            .enter().append("svg:path")
            .attr("d", path)
            .on("click", clicked);
        collection.features.forEach(function(coords) {
            var countrycode = getFromArrayByCountryName(countryCodes, coords.properties.name);
            if (countrycode == null) countrycode = ({countryname: coords.properties.name, countrycode2: "not available"});;
            countryCodeCenters.push({country: coords.properties.name, codetwo: countrycode.countrycode2, codethree: coords.id, center: getCenter(coords, coords.geometry.type).coordinates});
        });
        console.log(countryCodeCenters);

        // Create a path for each source/target pair.
        arcs.selectAll("path")
            .data(arcdata)
            .enter()
            .append("path")
            .attr('d', function(d) {
                var quantites = 15;
                if (d.importQuant != null) quantites = d.importQuant;
                return lngLatToArc(d, 'sourceLocation', 'targetLocation', quantites); // A bend of 5 looks nice and subtle, but this will depend on the length of your arcs and the visual look your visualization requires. Higher number equals less bend.
            });

    });




    // --------------- Zoom & Pan functionality -----------------------------

    var zoom = d3.behavior.zoom()
        .translate([defaultTranslateX, defaultTranslateY])
        .scale(defaultZoom)
        .scaleExtent([defaultZoom, 100])
        .on("zoom", zoomed);

    d3.select("body")
        .call(zoom);

    function zoomed() {
        console.log("zoooming");
        svg.transition()
            .duration(750)
            .attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")")
            ;
    }

    // --------------------- Click functionality -----------------------------

    function clicked(d) {
        // ... add click functionality!


        var selection = d3.select(this).style("fill", "black");
        selection.classed("selected", !selection.classed("selected"));

        if (selection.classed("selected")==false) {
            selection.style("fill", "LightGray");
            console.log("WHITE");
        }

        //sehr unperformant weil jedesmal über die csv drüber iteriert wird. besser wenn array direkt geschrieben wird ???

        console.log(d.properties.name);

            arcdataTrade.forEach(function (trade) {
                var importer = trade.importCountry,
                    exporter = trade.exportCountry,
                    importLocation = trade.importLocation,
                    exportLocation = trade.exportLocation;

                    if(exporter == d.properties.name) {
                        console.log(exporter);
                        arcdataTradeSelected.push({
                            exportCountry: exporter, importCountry: importer,
                            exportLocation: exportLocation,
                            importLocation: importLocation
                        });
                }
            });

            arcsTrade.selectAll("arc")
             .data(arcdataTradeSelected)
             .enter()
             .append("svg:path")
              .style("fill", "Red")
             .attr('d', function(d) {
             return lngLatToArc(d, 'exportLocation', 'importLocation', 25); // A bend of 5 looks nice and subtle, but this will depend on the length of your arcs and the visual look your visualization requires. Higher number equals less bend.
             });


        //var centerPoint = getCenter(d);
        //console.log(centerPoint);

    }



    // ----------------------------- DATA (still airport)-----------------------------------------

    d3.csv("/data/flights-airport.csv", function(flights) {
        var linksByOrigin = {},
            countByAirport = {},
            locationByAirport = {},
            positions = [];

        flights.forEach(function(flight) {
            var origin = flight.origin,
                destination = flight.destination,
                links = linksByOrigin[origin] || (linksByOrigin[origin] = []);
            links.push({source: origin, target: destination});
            countByAirport[origin] = (countByAirport[origin] || 0) + 1;
            countByAirport[destination] = (countByAirport[destination] || 0) + 1;
        });

        d3.csv("/data/airports.csv", function(airports) {

            // Only consider airports with at least one flight.
            airports = airports.filter(function(airport) {
                if (countByAirport[airport.iata]) {
                    var location = [+airport.longitude, +airport.latitude];
                    locationByAirport[airport.iata] = location;
                    positions.push(projection(location));
                    //console.log("loc of airport: " + location);
                    return true;
                }
            });

            circles.selectAll("circle")
                .data(airports)
                .enter().append("svg:circle")
                .attr("cx", function(d, i) { return positions[i][0]; })
                .attr("cy", function(d, i) { return positions[i][1]; })
                .attr("r", function(d, i) { return Math.sqrt(countByAirport[d.iata]); })
                .sort(function(a, b) { return countByAirport[b.iata] - countByAirport[a.iata]; });
        });
    });


    d3.csv("/data/animalTrade.csv", function(trades) {
        var linksByExporter = {},
            countByCountry = {},
            locationByCountry = {};

        trades.forEach(function (trade) {
            var importer = trade.Importer,
                exporter = trade.Exporter,
                quantityImp = trade['Importer reported quantity'], //empty spaces!!!
                links = linksByExporter[exporter] || (linksByExporter[exporter] = []);

            links.push({exportCountry: exporter, importCountry: importer});
            var exportInfo = getFromArrayByTwoDigits(countryCodeCenters, exporter);
            var importInfo = getFromArrayByTwoDigits(countryCodeCenters, importer);
            if (exportInfo != null && importInfo != null) { //if the country codes are available!
                    arcdataTrade.push({
                        exportCountry: exportInfo.country, importCountry: importInfo.country,
                        exportLocation: exportInfo.center,
                        importLocation: importInfo.center,
                        importQuant: quantityImp
                    });
                    countByCountry[exporter] = (countByCountry[exporter] || 0) + 1;
                    countByCountry[importer] = (countByCountry[importer] || 0) + 1;
            }
        });
        console.log(arcdataTrade);

    });

    /*rename of Russian Federation -> Russia
    Congo, the Democratic Republic of the -> Democratic Republic of the Congo
     United States -> United States of America
     "Bolivia, Plurinational State of -> Bolivia
     Venezuela, Bolivarian Republic of -> Venezuela
     Syrian Arab Republic -> Syria
     Tanzania, United Republic of -> United Republic of Tanzania
     Côte d'Ivoire -> Ivory Coast
     Iran, Islamic Republic of -> Iran
     Viet Nam -> Vietnam
     Korea, Republic of -> South Korea
     Korea, Democratic People's Republic of -> North Korea
     Taiwan, Province of China -> Taiwan
    */
    d3.csv("/data/cc2digit.csv", function(codes) {
        codes.forEach(function (code) {
            countryCodes.push({countryname: code.Name, countrycode2: code.Code});
        });
    });



        // ----------------------------- Functions -----------------------------------------

    function getCenter(polygon, geometryType) {
        if ('geometry' in polygon) polygon = polygon.geometry

        if (!Array.isArray(polygon)) {
            if (geometryType == "Polygon") {
                polygon = polygon.coordinates[0]
            }
            //find out the centerpoint of the largest coordinate array!
            else if (geometryType == "MultiPolygon") {

                var counter = 0;
                var longestArray = 0;
                var longestArrayLength = 0;
                polygon.coordinates.forEach(function (arrays) {
                    arrays.forEach(function (arraySecond){
                        counter = counter + 1;
                        if(arraySecond.length > longestArrayLength){
                            longestArrayLength = arraySecond.length;
                            longestArray = counter;
                        }
                    });
                });
                polygon = polygon.coordinates[longestArray-1][0]
            }
        }


        var minx = miny = 1000
            ,   maxx = maxy = -1000
        for (var i = 0; i < polygon.length; i++) {
            var point = polygon[i]
            var x = point[0]
            var y = point[1]

            if (x < minx) minx = x
            else if (x > maxx) maxx = x
            if (y < miny) miny = y
            else if (y > maxy) maxy = y
        }

        return {
            type: 'Point',
            coordinates: [
                minx + ((maxx - minx) / 2),
                miny + ((maxy - miny) / 2)
            ]
        }
    }

    function getFromArrayByCountryName(arr, value) {

        var result = [];
        arr.forEach(function(o){if (o.countryname === value) result.push(o);} );
        return result? result[0] : null; // or undefined
    }

    function getFromArrayByTwoDigits(arr, value) {

        var result = [];
        arr.forEach(function(o){if (o.codetwo === value) result.push(o);} );
        return result? result[0] : null; // or undefined

    }





    // ----------------------------- Center of Country -----------------------------------------

    var arcdata = [
        {
            sourceLocation: [-99.5606025, 41.068178502813595],
            targetLocation: [-106.503961875, 33.051502817366334]
        },
        {
            sourceLocation: [-99.5606025, 81.068178502813595],
            targetLocation: [-150.27544625, 34.29490081496779]
        },
        {
            sourceLocation: [-99.5606025, 41.068178502813595],
            targetLocation: [-92.793024375, 64.837711658059135]
        }
    ]


    // This function takes an object, the key names where it will find an array of lng/lat pairs, e.g. `[-74, 40]`
    // And a bend parameter for how much bend you want in your arcs, the higher the number, the less bend.
    function lngLatToArc(d, sourceName, targetName, bend){
        // If no bend is supplied, then do the plain square root
        //console.log(d);
        bend = bend || 1;
        // `d[sourceName]` and `d[targetname]` are arrays of `[lng, lat]`
        // Note, people often put these in lat then lng, but mathematically we want x then y which is `lng,lat`

        var sourceLngLat = d[sourceName],
            targetLngLat = d[targetName];

        if (targetLngLat && sourceLngLat) {
            var sourceXY = projection( sourceLngLat ),
                targetXY = projection( targetLngLat );

            // Uncomment this for testing, useful to see if you have any null lng/lat values
            // if (!targetXY) console.log(d, targetLngLat, targetXY)
            var sourceX = sourceXY[0],
                sourceY = sourceXY[1];

            var targetX = targetXY[0],
                targetY = targetXY[1];

            var dx = targetX - sourceX,
                dy = targetY - sourceY,
                dr = Math.sqrt(dx * dx + dy * dy)*bend;

            // To avoid a whirlpool effect, make the bend direction consistent regardless of whether the source is east or west of the target
            var west_of_source = (targetX - sourceX) < 0;
            if (west_of_source) return "M" + targetX + "," + targetY + "A" + dr + "," + dr + " 0 0,1 " + sourceX + "," + sourceY;
            return "M" + sourceX + "," + sourceY + "A" + dr + "," + dr + " 0 0,1 " + targetX + "," + targetY;

        } else {
            return "M0,0,l0,0z";
        }
    }

</script>
</body>